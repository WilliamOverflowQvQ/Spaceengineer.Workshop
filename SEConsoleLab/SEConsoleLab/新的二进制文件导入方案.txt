新的二进制文件导入SE程序块的方案：
20181202

在SE程序块导入二进制文件时最繁琐的问题既是：“如何避免导入字符串时出现'Null'错误”。

解决办法1：插入法
将文件中所有的null(0x00000000)标注其位置，记录并剔除；
在导入文件后在指定位置插入null。

优化方案：
在记录null的位置后再记录和该null相连的其他null，以此可以大幅节约空间。

Pros：
在某些情况下处理速度变快（取决于null的数量等...，例子：一张纯黑图片；全是null（23333））；
节约了很多空间

Cons：
处理速度非常慢（取决于null的数量与分散情况）；


解决办法2：替换法
某些文件的信息单一，以某个在文件中不可能出现的字符替代null，比如0xFFFF就很少出现
在导入文件后在处理时替换

Pros:
代码简单，步数少

Cons:
一堆

解决办法3：组替换法
尝试找出某一文件的规律，并替换其中重复的部分；
例子：123aaa123sbw123osoajdwdcm123000000123aaa可以抽出123进行过替换...
Pros：
解压缩时非常简单

Cons：
压缩方法非常复杂

解决办法3：分层替换法 (2019 01 28)
将源数据中数据单元的null替换为很少出现的数据单元，
例：0x0000 0x0123 0x0312 0x0F21 0xFFFF 0x2112 0x0000
    0xFFFF 0x0123 0x0312 0x0F21 0xFFFF 0x2112 0xFFFF
	0      1      2      3      4 ^^^^ 5      6
	而中间出现的'很少出现的数据单元'的位置被记录下，另行储存
	0xFFFF 0x0123 0x0312 0x0F21 0xFFFF 0x2112 0xFFFF | 0x0004

Pros：
压缩时非常容易，解压缩时也十分迅速。

Cons：
怎么处理分割两项数据的问题？（即中间的'|'怎么代替为数据？）
    二次分开的加入数据->让操作者自己在两个数据中间进行操作。
	**这个问题仅仅建立在第二数据也被压缩，且很可能因巧合导致数据混淆的情况



